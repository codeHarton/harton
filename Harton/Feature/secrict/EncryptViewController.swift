//
//  EncryptViewController.swift
//  Harton
//
//  Created by harton on 2021/8/18.
//

import UIKit
import CryptoSwift
class EncryptViewController: BaseViewController {
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // Do any additional setup after loading the view.
    }
    
    ///签名算法
    func MD5_SHA256(){
        /**
         MD5特点
         1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。
         2、容易计算：从原数据计算出MD5值很容易。
         3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
         4、弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。
         5、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。
         6、MD5加密是不可解密的，但是网上有一些解析MD5的，那个相当于一个大型的数据库，通过匹配MD5去找到原密码。所以，只要在要加密的字符串前面加上一些字母数字符号或者多次MD5加密，这样出来的结果一般是解析不出来的。
         
         MD5好处
         1、压缩到固定长度128bit，长度小适合互联网传输；
         2、相同文件多次压缩的值不变，常用于对文件的是否被篡改的校验；
         3、不同文件压缩后出现值冲突的几率很小；
         4、md5算法比同类的sha-1计算速度快；
         
         MD5应用
         
         1、一致性验证：MD5的典型应用是对一段信息（Message）产生信息摘要（Message-Digest），以防止被篡改。MD5就可以为任何文件（不管其大小、格式、数量）产生一个同样独一无二的“数字指纹”，如果任何人对文件做了任何改动，其MD5值也就是对应的“数字指纹”都会发生变化。
         
         2、数字签名：MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹），以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现（两个MD5值不相同）。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。
         
         3、安全访问认证：MD5还广泛用于操作系统的登陆认证上，如Unix、各类BSD系统登录密码、数字签名等诸多方面。如在Unix系统中用户的密码是以MD5（或其它类似的算法）经Hash运算后存储在文件系统中。当用户登录的时候，系统把用户输入的密码进行MD5 Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这可以避免用户的密码被具有系统管理员权限的用户知道。
      
         客户端应用
         1、本地数据加密：对NSUserDefaults，qlite，存储文件数据加密，保护帐号和关键信息。
         2、URL编码加密：对程序中出现的URL进行编码加密，防止URL被静态分析
         3、网络传输数据加密：对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取
         4、方法体，方法名高级混淆：对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码
         5、程序结构混排加密：对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低
         
         MD5虽然说是不可逆的，但是由于有网站的存在，专门用来查询MD5码，所以有的简单的MD5码是可以在这里搜到源码的。为了让MD5码更加安全 涌现了很多其他方法，如加盐。盐要足够长足够乱得到的MD5码就很难查到。
         
         
         ————————————————
         版权声明：本文为CSDN博主「Z苗」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
         原文链接：https://blog.csdn.net/Z1591090/article/details/103774282
         */
    }
    
    /**
     对称加密和非对称加密场景的差异
     对称加密：适合经常发送数据的场合
     非对称加密：加密和解密用的密钥是不同的，通常加密解密的速度比较慢，适合偶尔发送数据的场合。优点是密钥传输方便。
     */
    
    /**
     1、最常用的对称加密算法
     2、密钥建立时间短、灵敏性好、内存需求低
     3、实际使用中，使用工作模式为CTR（最好用BC去实现），此工作模式需要引入IV参数（16位的字节数组）
     4、密钥长度128/192/256，其中192与256需要配置无政策限制权限文件（JDK6）
     5、填充模式最常用的两种PKCS5Padding和PKCS7Padding，其中后者只有BC独有。
     6、加密和解密用到的密钥是相同的，这种加密方式加密速度非常快，适合经常发送数据的场合。
     */
    func AES(){
        
    }
    
    /**
     RSA 加密方式相信每一个对接过支付宝SDK的同学都听过这个RSA加密，因为支付宝SDK的加密方式采用的就是这种。
     它的一个大致额历程是这样：
     1、生成你的公钥给支付宝，注册支付宝SDK之后你也可以拿到支付宝公钥。
     2、上传你的公钥到支付宝，用你的私钥加密你的信息，支付包用你上传的公钥解密你传给支付宝的信息。
     3、用你拿到的支付宝的公钥解密支付宝回调给你的信息。
     注意：不要把这新秘钥信息存放在客户端，存放在服务端也建议不要使用明文的形式存储，安全问题！有些说把秘钥制作成.a文件的形式存放的客户端，问题反编译之后直接拿到你这份.a文件是不是也可以用用呢？
     RSA是目前最有影响力的公钥加密算法，该算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，
     
     因此可以将乘积公开作为加密密钥，即公钥，而两个大素数组合成私钥。公钥是可发布的供任何人使用，私钥则为自己所有，供解密之用。
     */
    func RSA(){
        
    }
    
    
}

